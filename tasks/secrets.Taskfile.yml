# ##################################################################################################
# File: tasks/secrets.Taskfile.yml
# Description:
#   Secrets management Taskfile for fouchger-homelab.
#
#   This Taskfile standardises two complementary patterns:
#     1) SOPS + age for Git-encrypted configuration state:
#        - API keys rotated manually
#        - App config secrets not generated on demand
#        - Ansible inventory/group_vars and similar configuration state
#
#     2) OpenBao for dynamic and centrally governed secrets:
#        - Database credentials issued with TTL
#        - PKI/cert issuance, short-lived tokens
#        - Central audit trail and policy-based access (multi-admin ready)
#
# Notes:
#   - Debian/Ubuntu oriented (works well on Ubuntu 24.04 in VMs/LXCs).
#   - This file is designed to be safe for headless use.
#   - It creates opinionated defaults but keeps “break glass” options explicit.
#
# Repo conventions created by this Taskfile:
#   - secrets/age/                 (age keys, not committed)
#   - secrets/sops/                (encrypted secrets/config state, committed)
#   - secrets/openbao/             (OpenBao config + encrypted bootstrap artefacts)
#   - ansible/group_vars/...       (encrypted with SOPS where appropriate)
#   - .sops.yaml                   (SOPS rules)
#
# Hardening guidance (recommended):
#   - Keep age identity private keys off Git and off shared filesystems.
#   - Use SOPS rules that force encryption for secrets paths.
#   - For OpenBao, consider swap controls and systemd MemorySwapMax=0 where possible. :contentReference[oaicite:0]{index=0}
# ##################################################################################################

version: "3"

vars:
  SUDO: "{{.SUDO | default \"sudo\"}}"
  APT_GET: "{{.APT_GET | default \"apt-get\"}}"
  DEBIAN_FRONTEND: "noninteractive"

  # Repo layout
  SECRETS_DIR: "secrets"
  AGE_DIR: "{{.SECRETS_DIR}}/age"
  SOPS_DIR: "{{.SECRETS_DIR}}/sops"
  OPENBAO_DIR: "{{.SECRETS_DIR}}/openbao"

  # age identity paths (NOT to be committed)
  AGE_IDENTITY_FILE: "{{.AGE_DIR}}/age-key.txt"
  AGE_RECIPIENTS_FILE: "{{.AGE_DIR}}/age-recipients.txt"

  # SOPS config file (committed)
  SOPS_CONFIG_FILE: ".sops.yaml"

  # OpenBao defaults (adjust for your topology)
  OPENBAO_VERSION: "{{.OPENBAO_VERSION | default \"latest\"}}"
  OPENBAO_BIN: "/usr/local/bin/bao"
  OPENBAO_USER: "openbao"
  OPENBAO_GROUP: "openbao"
  OPENBAO_CONFIG_DIR: "/etc/openbao"
  OPENBAO_DATA_DIR: "/var/lib/openbao"
  OPENBAO_SERVICE: "openbao"

  # Listener defaults: secure-by-default for a single-node homelab.
  # Start bound to localhost; later you can front it with a reverse proxy and proper TLS.
  OPENBAO_LISTEN_ADDRESS: "{{.OPENBAO_LISTEN_ADDRESS | default \"127.0.0.1:8200\"}}"
  OPENBAO_API_ADDR: "{{.OPENBAO_API_ADDR | default \"http://127.0.0.1:8200\"}}"

  # Bootstrap artefacts stored as SOPS-encrypted YAML (committed).
  OPENBAO_BOOTSTRAP_ENC: "{{.OPENBAO_DIR}}/bootstrap.enc.yaml"

tasks:
  # ------------------------------------------------------------------------------------------------
  # One-liner meta task
  # ------------------------------------------------------------------------------------------------
  secrets:
    desc: "Install and set up SOPS+age, SSH keys, and OpenBao baseline (safe defaults)."
    cmds:
      - task: prereqs
      - task: dirs
      - task: age:install
      - task: sops:install
      - task: age:init
      - task: sops:init
      - task: ssh:install
      - task: ssh:keys
      - task: openbao:install
      - task: openbao:configure
      - task: openbao:service
      - task: openbao:init
      - task: openbao:policies:baseline
      - task: verify
    silent: false

  # ------------------------------------------------------------------------------------------------
  # Prereqs and folder structure
  # ------------------------------------------------------------------------------------------------
  prereqs:
    desc: "Ensure base tools exist (curl, unzip, jq)."
    cmds:
      - "{{.SUDO}} {{.APT_GET}} update"
      - "{{.SUDO}} {{.APT_GET}} install -y ca-certificates curl unzip jq coreutils findutils"
    status:
      - command -v curl
      - command -v unzip
      - command -v jq

  dirs:
    desc: "Create secrets folder structure (safe defaults)."
    cmds:
      - "mkdir -p {{.AGE_DIR}} {{.SOPS_DIR}} {{.OPENBAO_DIR}}"
      - "mkdir -p ansible/group_vars/all ansible/group_vars/prod ansible/group_vars/dev"
      - "chmod 700 {{.AGE_DIR}}"
      - "chmod 755 {{.SOPS_DIR}} {{.OPENBAO_DIR}}"
    status:
      - test -d "{{.AGE_DIR}}"
      - test -d "{{.SOPS_DIR}}"
      - test -d "{{.OPENBAO_DIR}}"

  # ------------------------------------------------------------------------------------------------
  # age (preferred recipient mechanism for SOPS)
  # ------------------------------------------------------------------------------------------------
  age:install:
    desc: "Install age (prefers apt; falls back to snap if needed)."
    cmds:
      - |
        set -euo pipefail
        if command -v age >/dev/null 2>&1 && command -v age-keygen >/dev/null 2>&1; then
          echo "age already installed."
          exit 0
        fi

        if {{.APT_GET}} -qq show age >/dev/null 2>&1; then
          {{.SUDO}} {{.APT_GET}} install -y age
          exit 0
        fi

        # Snap fallback: useful on minimal images where apt package is unavailable.
        # If snap isn't present, install it.
        if ! command -v snap >/dev/null 2>&1; then
          {{.SUDO}} {{.APT_GET}} install -y snapd
        fi
        {{.SUDO}} snap install age-encryption
    status:
      - command -v age
      - command -v age-keygen
    # age is a modern encryption tool designed for small explicit keys and UNIX composability. :contentReference[oaicite:1]{index=1}

  age:init:
    desc: "Create an age identity (private) and recipients list (public) for repo encryption."
    cmds:
      - |
        set -euo pipefail

        mkdir -p "{{.AGE_DIR}}"
        chmod 700 "{{.AGE_DIR}}"

        if [ ! -f "{{.AGE_IDENTITY_FILE}}" ]; then
          echo "Generating age identity at {{.AGE_IDENTITY_FILE}}"
          age-keygen -o "{{.AGE_IDENTITY_FILE}}"
          chmod 600 "{{.AGE_IDENTITY_FILE}}"
        else
          echo "age identity already exists: {{.AGE_IDENTITY_FILE}}"
        fi

        # Extract public key and write a recipients file (safe to share within your admin team).
        PUB="$(grep -E '^# public key:' -m 1 "{{.AGE_IDENTITY_FILE}}" | awk '{print $4}')"
        if [ -z "${PUB}" ]; then
          echo "Could not extract public key from {{.AGE_IDENTITY_FILE}}"
          exit 1
        fi

        echo "${PUB}" > "{{.AGE_RECIPIENTS_FILE}}"
        chmod 644 "{{.AGE_RECIPIENTS_FILE}}"

        echo
        echo "Public recipient written to {{.AGE_RECIPIENTS_FILE}}:"
        echo "  ${PUB}"
        echo
        echo "Important: do not commit {{.AGE_IDENTITY_FILE}} to Git."
    status:
      - test -f "{{.AGE_IDENTITY_FILE}}"
      - test -f "{{.AGE_RECIPIENTS_FILE}}"

  # ------------------------------------------------------------------------------------------------
  # SOPS (Git-encrypted files using age recipients)
  # ------------------------------------------------------------------------------------------------
  sops:install:
    desc: "Install SOPS (prefers apt; falls back to GitHub release)."
    cmds:
      - |
        set -euo pipefail
        if command -v sops >/dev/null 2>&1; then
          echo "sops already installed."
          exit 0
        fi

        if {{.APT_GET}} -qq show sops >/dev/null 2>&1; then
          {{.SUDO}} {{.APT_GET}} install -y sops
          exit 0
        fi

        # Fallback to GitHub latest release.
        # SOPS supports age, KMS backends, and multiple structured formats. :contentReference[oaicite:2]{index=2}
        echo "Installing sops from GitHub latest release..."
        TMP="$(mktemp -d)"
        trap 'rm -rf "${TMP}"' EXIT

        TAG="$(curl -fsSL https://api.github.com/repos/getsops/sops/releases/latest | jq -r '.tag_name')"
        [ -n "${TAG}" ] && [ "${TAG}" != "null" ]

        # Detect architecture
        ARCH="$(uname -m)"
        case "${ARCH}" in
          x86_64|amd64)   ASSET="sops-${TAG}.linux.amd64" ;;
          aarch64|arm64)  ASSET="sops-${TAG}.linux.arm64" ;;
          *)
            echo "Unsupported architecture for SOPS fallback install: ${ARCH}"
            exit 1
            ;;
        esac

        curl -fsSL -o "${TMP}/sops" "https://github.com/getsops/sops/releases/download/${TAG}/${ASSET}"
        chmod +x "${TMP}/sops"
        {{.SUDO}} install -m 0755 "${TMP}/sops" /usr/local/bin/sops
    status:
      - command -v sops

  sops:init:
    desc: "Create .sops.yaml and repo guardrails for encrypting configuration state."
    cmds:
      - |
        set -euo pipefail

        if [ ! -f "{{.AGE_RECIPIENTS_FILE}}" ]; then
          echo "Missing recipients file: {{.AGE_RECIPIENTS_FILE}} (run: task -t tasks/secrets.Taskfile.yml age:init)"
          exit 1
        fi

        RECIPIENT="$(head -n 1 "{{.AGE_RECIPIENTS_FILE}}")"
        if [ -z "${RECIPIENT}" ]; then
          echo "Recipients file is empty: {{.AGE_RECIPIENTS_FILE}}"
          exit 1
        fi

        if [ ! -f "{{.SOPS_CONFIG_FILE}}" ]; then
          cat > "{{.SOPS_CONFIG_FILE}}" <<EOF
# ##################################################################################################
# File: .sops.yaml
# Purpose:
#   SOPS encryption rules for fouchger-homelab.
#
# Notes:
#   - This config enforces SOPS+age encryption for common secrets locations.
#   - Keep this file committed to Git.
#   - Update recipients as your admin set evolves.
# ##################################################################################################

creation_rules:
  # Anything under secrets/sops is always encrypted
  - path_regex: ^secrets/sops/.*\\.(ya?ml|json|env|ini)$
    encrypted_regex: '^(data|stringData|secrets|secret|token|password|key|keys|private|config)$'
    age: ${RECIPIENT}

  # Common Ansible var files containing secrets
  - path_regex: ^ansible/group_vars/.*/.*(secret|secrets)\\.(ya?ml|json)$
    age: ${RECIPIENT}

  # OpenBao bootstrap artefacts (encrypted at rest in Git)
  - path_regex: ^secrets/openbao/.*\\.(ya?ml|json)$
    age: ${RECIPIENT}
EOF
          echo "Created {{.SOPS_CONFIG_FILE}}"
        else
          echo "{{.SOPS_CONFIG_FILE}} already exists (no changes made)."
        fi

        # Create a sensible .gitignore for age private keys and local-only artefacts.
        if [ ! -f ".gitignore" ]; then
          touch .gitignore
        fi

        if ! grep -qE '^secrets/age/' .gitignore; then
          cat >> .gitignore <<'EOF'

# Secrets tooling private material (do not commit)
secrets/age/
EOF
        fi

        # Provide a starter encrypted file to prove the toolchain works.
        if [ ! -f "{{.SOPS_DIR}}/README.md" ]; then
          cat > "{{.SOPS_DIR}}/README.md" <<'EOF'
# Encrypted secrets (SOPS)

Store Git-encrypted configuration state here (YAML/JSON/ENV/INI).

Examples:
- API keys rotated manually
- app config secrets
- Ansible group_vars secrets files

Do not store age private keys here. Those live under secrets/age/ which is ignored by Git.
EOF
        fi

  sops:encrypt:
    desc: "Encrypt a file in-place with SOPS (usage: task sops:encrypt -- FILE=path)."
    vars:
      FILE: "{{.FILE}}"
    cmds:
      - |
        set -euo pipefail
        [ -n "{{.FILE}}" ] || (echo "FILE is required, e.g. task sops:encrypt -- FILE=secrets/sops/app.yaml" && exit 1)
        sops -e -i "{{.FILE}}"

  sops:decrypt:
    desc: "Decrypt a file to stdout (usage: task sops:decrypt -- FILE=path)."
    vars:
      FILE: "{{.FILE}}"
    cmds:
      - |
        set -euo pipefail
        [ -n "{{.FILE}}" ] || (echo "FILE is required, e.g. task sops:decrypt -- FILE=secrets/sops/app.yaml" && exit 1)
        sops -d "{{.FILE}}"

  # ------------------------------------------------------------------------------------------------
  # SSH keys and agent basics (for Git + host access)
  # ------------------------------------------------------------------------------------------------
  ssh:install:
    desc: "Install SSH client tooling and optional helper utilities."
    cmds:
      - "{{.SUDO}} {{.APT_GET}} install -y openssh-client openssh-server keychain"
    status:
      - command -v ssh
      - command -v ssh-keygen

  ssh:keys:
    desc: "Create SSH keys (ed25519) for the current user if missing."
    vars:
      SSH_KEY: "{{.SSH_KEY | default (printf \"%s/.ssh/id_ed25519\" .HOME)}}"
      SSH_COMMENT: "{{.SSH_COMMENT | default \"fouchger-homelab\"}}"
    cmds:
      - |
        set -euo pipefail

        mkdir -p "$(dirname "{{.SSH_KEY}}")"
        chmod 700 "$(dirname "{{.SSH_KEY}}")"

        if [ -f "{{.SSH_KEY}}" ]; then
          echo "SSH key already exists: {{.SSH_KEY}}"
        else
          echo "Creating SSH key: {{.SSH_KEY}}"
          echo "You will be prompted for a passphrase (recommended)."
          ssh-keygen -t ed25519 -a 64 -C "{{.SSH_COMMENT}}" -f "{{.SSH_KEY}}"
          chmod 600 "{{.SSH_KEY}}"
          chmod 644 "{{.SSH_KEY}}.pub"
        fi

        echo
        echo "Public key:"
        cat "{{.SSH_KEY}}.pub"
        echo

        # Set up a lightweight agent hook for interactive shells (safe for headless).
        # Keychain will only prompt when needed.
        if [ -f "${HOME}/.bashrc" ] && ! grep -q "keychain.*id_ed25519" "${HOME}/.bashrc"; then
          cat >> "${HOME}/.bashrc" <<'EOF'

# fouchger-homelab: SSH agent convenience (headless friendly)
# Keychain manages an ssh-agent across sessions.
if command -v keychain >/dev/null 2>&1; then
  eval "$(keychain --eval --quiet id_ed25519)"
fi
EOF
          echo "Updated ~/.bashrc with keychain snippet (effective on next shell start)."
        fi

  # ------------------------------------------------------------------------------------------------
  # OpenBao (dynamic secrets, audit, policies)
  # ------------------------------------------------------------------------------------------------
  openbao:install:
    desc: "Install OpenBao CLI/server (downloads latest by default)."
    cmds:
      - |
        set -euo pipefail

        if command -v bao >/dev/null 2>&1; then
          echo "OpenBao already installed."
          exit 0
        fi

        TMP="$(mktemp -d)"
        trap 'rm -rf "${TMP}"' EXIT

        if [ "{{.OPENBAO_VERSION}}" = "latest" ]; then
          TAG="$(curl -fsSL https://api.github.com/repos/openbao/openbao/releases/latest | jq -r '.tag_name')"
        else
          TAG="{{.OPENBAO_VERSION}}"
        fi

        [ -n "${TAG}" ] && [ "${TAG}" != "null" ]

        ARCH="$(uname -m)"
        case "${ARCH}" in
          x86_64|amd64)   ZIP="openbao_${TAG#v}_linux_amd64.zip" ;;
          aarch64|arm64)  ZIP="openbao_${TAG#v}_linux_arm64.zip" ;;
          *)
            echo "Unsupported architecture for OpenBao install: ${ARCH}"
            exit 1
            ;;
        esac

        echo "Downloading OpenBao ${TAG} (${ZIP})..."
        curl -fsSL -o "${TMP}/${ZIP}" "https://github.com/openbao/openbao/releases/download/${TAG}/${ZIP}"
        unzip -q "${TMP}/${ZIP}" -d "${TMP}"

        {{.SUDO}} install -m 0755 "${TMP}/bao" "{{.OPENBAO_BIN}}"
        echo "Installed: {{.OPENBAO_BIN}}"
    status:
      - command -v bao
    # OpenBao install options are documented (package manager, containers, binaries). :contentReference[oaicite:3]{index=3}

  openbao:configure:
    desc: "Create OpenBao user, directories, and baseline config (file storage, localhost listener)."
    cmds:
      - |
        set -euo pipefail

        if ! getent group "{{.OPENBAO_GROUP}}" >/dev/null; then
          {{.SUDO}} groupadd --system "{{.OPENBAO_GROUP}}"
        fi
        if ! id -u "{{.OPENBAO_USER}}" >/dev/null 2>&1; then
          {{.SUDO}} useradd --system --home "{{.OPENBAO_DATA_DIR}}" --shell /usr/sbin/nologin --gid "{{.OPENBAO_GROUP}}" "{{.OPENBAO_USER}}"
        fi

        {{.SUDO}} mkdir -p "{{.OPENBAO_CONFIG_DIR}}" "{{.OPENBAO_DATA_DIR}}"
        {{.SUDO}} chown -R "{{.OPENBAO_USER}}:{{.OPENBAO_GROUP}}" "{{.OPENBAO_CONFIG_DIR}}" "{{.OPENBAO_DATA_DIR}}"
        {{.SUDO}} chmod 750 "{{.OPENBAO_CONFIG_DIR}}" "{{.OPENBAO_DATA_DIR}}"

        # Baseline config: local listener, file backend.
        # For production-grade setups, move to TLS and consider integrated storage/HA patterns.
        if [ ! -f "{{.OPENBAO_CONFIG_DIR}}/openbao.hcl" ]; then
          cat > /tmp/openbao.hcl <<EOF
# ##################################################################################################
# File: /etc/openbao/openbao.hcl
# Purpose:
#   Baseline OpenBao configuration for a single-node homelab.
#
# Notes:
#   - Binds to localhost by default (safe).
#   - Uses file storage (simple). For growth, consider HA storage patterns.
#   - You can front this with a reverse proxy and TLS when ready.
# ##################################################################################################

ui = true
api_addr = "{{.OPENBAO_API_ADDR}}"

storage "file" {
  path = "{{.OPENBAO_DATA_DIR}}"
}

listener "tcp" {
  address     = "{{.OPENBAO_LISTEN_ADDRESS}}"
  tls_disable = 1
}

disable_mlock = true
EOF
          {{.SUDO}} install -m 0640 -o "{{.OPENBAO_USER}}" -g "{{.OPENBAO_GROUP}}" /tmp/openbao.hcl "{{.OPENBAO_CONFIG_DIR}}/openbao.hcl"
          rm -f /tmp/openbao.hcl
        fi

  openbao:service:
    desc: "Install and start systemd service for OpenBao."
    cmds:
      - |
        set -euo pipefail

        if [ ! -d /etc/systemd/system ]; then
          echo "systemd not detected. Use OpenBao in dev mode or container mode on this host."
          exit 1
        fi

        if [ ! -f "/etc/systemd/system/{{.OPENBAO_SERVICE}}.service" ]; then
          cat > /tmp/openbao.service <<'EOF'
# ##################################################################################################
# File: /etc/systemd/system/openbao.service
# Purpose:
#   Run OpenBao as a service.
#
# Notes:
#   - Uses MemorySwapMax=0 to reduce swap exposure where supported.
#   - If your host needs swap, consider encrypted swap rather than disabling swap globally.
# ##################################################################################################
[Unit]
Description=OpenBao
After=network-online.target
Wants=network-online.target

[Service]
User=openbao
Group=openbao
ExecStart=/usr/local/bin/bao server -config=/etc/openbao/openbao.hcl
ExecReload=/bin/kill --signal HUP $MAINPID
KillMode=process
KillSignal=SIGINT
Restart=on-failure
RestartSec=5
LimitNOFILE=65536
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
MemorySwapMax=0

[Install]
WantedBy=multi-user.target
EOF
          {{.SUDO}} install -m 0644 /tmp/openbao.service "/etc/systemd/system/{{.OPENBAO_SERVICE}}.service"
          rm -f /tmp/openbao.service
        fi

        {{.SUDO}} systemctl daemon-reload
        {{.SUDO}} systemctl enable --now "{{.OPENBAO_SERVICE}}"
        {{.SUDO}} systemctl --no-pager status "{{.OPENBAO_SERVICE}}" || true
    # Memory paging (swap) hardening is called out in OpenBao docs. :contentReference[oaicite:4]{index=4}

  openbao:init:
    desc: "Initialise OpenBao if not initialised, then store bootstrap info as SOPS-encrypted YAML."
    cmds:
      - |
        set -euo pipefail

        export BAO_ADDR="{{.OPENBAO_API_ADDR}}"

        # Wait briefly for service readiness
        for i in $(seq 1 30); do
          if bao status >/dev/null 2>&1; then
            break
          fi
          sleep 1
        done

        if bao status 2>/dev/null | grep -q "Initialized.*true"; then
          echo "OpenBao already initialised."
          exit 0
        fi

        echo "Initialising OpenBao (this will generate unseal keys and initial root token)."

        # Use JSON output, then convert to YAML-like format for operator friendliness.
        INIT_JSON="$(bao operator init -format=json -key-shares=5 -key-threshold=3)"
        [ -n "${INIT_JSON}" ]

        mkdir -p "{{.OPENBAO_DIR}}"
        TMPFILE="$(mktemp)"
        trap 'rm -f "${TMPFILE}"' EXIT

        cat > "${TMPFILE}" <<EOF
openbao:
  addr: "{{.OPENBAO_API_ADDR}}"
  generated_at_utc: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  init:
    key_shares: 5
    key_threshold: 3
    json: |
$(echo "${INIT_JSON}" | sed 's/^/      /')
EOF

        # Encrypt bootstrap artefacts into Git-safe file.
        sops -e -i "${TMPFILE}"
        mkdir -p "$(dirname "{{.OPENBAO_BOOTSTRAP_ENC}}")"
        mv "${TMPFILE}" "{{.OPENBAO_BOOTSTRAP_ENC}}"

        echo "Encrypted bootstrap saved to: {{.OPENBAO_BOOTSTRAP_ENC}}"
        echo
        echo "Next steps (operator runbook):"
        echo "  1) Decrypt bootstrap: task sops:decrypt -- FILE={{.OPENBAO_BOOTSTRAP_ENC}}"
        echo "  2) Unseal with 3 of 5 keys: bao operator unseal"
        echo "  3) Login with root token: bao login"
        echo
        echo "Important: rotate away from root token quickly and move to policies + approle/oidc."

  openbao:policies:baseline:
    desc: "Create baseline secret engines and a starter policy (requires OpenBao unsealed + operator login)."
    cmds:
      - |
        set -euo pipefail
        export BAO_ADDR="{{.OPENBAO_API_ADDR}}"

        # This task expects the operator to have already:
        # - unsealed OpenBao
        # - logged in (BAO_TOKEN set by `bao login` or exported)
        if ! bao token lookup >/dev/null 2>&1; then
          echo "Not logged in to OpenBao. Run: bao login (after unseal) and re-run this task."
          exit 1
        fi

        # Enable KV v2 for conventional secrets
        bao secrets enable -path=kv kv-v2 >/dev/null 2>&1 || true

        # Enable PKI (for cert issuance)
        bao secrets enable pki >/dev/null 2>&1 || true
        bao secrets tune -max-lease-ttl=8760h pki >/dev/null 2>&1 || true

        # Enable audit to file (simple, effective for single-node)
        {{.SUDO}} mkdir -p /var/log/openbao
        {{.SUDO}} chown "{{.OPENBAO_USER}}:{{.OPENBAO_GROUP}}" /var/log/openbao
        {{.SUDO}} chmod 750 /var/log/openbao

        bao audit enable file file_path=/var/log/openbao/audit.log >/dev/null 2>&1 || true

        # Starter policy for “homelab-admin” (tighten as you go).
        TMPPOL="$(mktemp)"
        trap 'rm -f "${TMPPOL}"' EXIT
        cat > "${TMPPOL}" <<'EOF'
# Baseline admin policy (starter). Tighten or split duties as the admin team grows.
path "sys/health" { capabilities = ["read", "sudo"] }
path "sys/mounts" { capabilities = ["read", "list"] }
path "sys/mounts/*" { capabilities = ["create", "read", "update", "delete", "list", "sudo"] }
path "auth/*" { capabilities = ["create", "read", "update", "delete", "list", "sudo"] }
path "sys/policies/acl/*" { capabilities = ["create", "read", "update", "delete", "list", "sudo"] }
path "kv/*" { capabilities = ["create", "read", "update", "delete", "list"] }
path "pki/*" { capabilities = ["create", "read", "update", "delete", "list", "sudo"] }
EOF

        bao policy write homelab-admin "${TMPPOL}"
        echo "Baseline engines enabled (kv-v2, pki, file audit) and policy homelab-admin created."

  # ------------------------------------------------------------------------------------------------
  # Verification and operator visibility
  # ------------------------------------------------------------------------------------------------
  verify:
    desc: "Verify installs and print operator-friendly status."
    cmds:
      - |
        set -euo pipefail
        echo "Tooling:"
        command -v age >/dev/null && echo "  age:   $(age --version 2>/dev/null || true)"
        command -v sops >/dev/null && echo "  sops:  $(sops --version 2>/dev/null | head -n 1 || true)"
        command -v bao >/dev/null && echo "  bao:   $(bao version 2>/dev/null || true)"
        command -v ssh >/dev/null && echo "  ssh:   $(ssh -V 2>&1 | head -n 1 || true)"
        echo
        echo "Repo structure:"
        test -f "{{.SOPS_CONFIG_FILE}}" && echo "  {{.SOPS_CONFIG_FILE}}: present"
        test -f "{{.AGE_IDENTITY_FILE}}" && echo "  {{.AGE_IDENTITY_FILE}}: present (private, not committed)"
        test -f "{{.AGE_RECIPIENTS_FILE}}" && echo "  {{.AGE_RECIPIENTS_FILE}}: present (public recipient)"
        test -f "{{.OPENBAO_BOOTSTRAP_ENC}}" && echo "  {{.OPENBAO_BOOTSTRAP_ENC}}: present (encrypted)"
        echo
        echo "OpenBao service:"
        if command -v systemctl >/dev/null 2>&1; then
          systemctl is-enabled "{{.OPENBAO_SERVICE}}" >/dev/null 2>&1 && echo "  enabled: yes" || echo "  enabled: no"
          systemctl is-active "{{.OPENBAO_SERVICE}}" >/dev/null 2>&1 && echo "  active:  yes" || echo "  active:  no"
        else
          echo "  systemd not detected."
        fi
        echo
        echo "Next moves:"
        echo "  - Encrypt Ansible secret vars: put files under ansible/group_vars/.../*secrets*.yml then: sops -e -i <file>"
        echo "  - For dynamic secrets: enable database engine and create roles with TTL in OpenBao."
        echo "  - Consider moving OpenBao listener behind TLS + auth method (OIDC or AppRole) as you scale admin access."

  # ------------------------------------------------------------------------------------------------
  # OpenBao Day 2: Backup and restore
  # ------------------------------------------------------------------------------------------------
  openbao:backup:
    desc: "Create a consistent OpenBao backup (stops service briefly), optionally SOPS-encrypts the tarball."
    vars:
      BACKUP_DIR: "{{.BACKUP_DIR | default (printf \"%s/backups/openbao\" .HOME)}}"
      ENCRYPT: "{{.ENCRYPT | default \"1\"}}" # 1 encrypt with sops, 0 leave plaintext tar.gz
      KEEP_DAYS: "{{.KEEP_DAYS | default \"30\"}}"
    cmds:
      - |
        set -euo pipefail

        TS="$(date -u +%Y%m%dT%H%M%SZ)"
        mkdir -p "{{.BACKUP_DIR}}"

        TAR="{{.BACKUP_DIR}}/openbao-backup-${TS}.tar.gz"
        ENC="${TAR}.sops"

        echo "Stopping OpenBao for a consistent snapshot..."
        {{.SUDO}} systemctl stop "{{.OPENBAO_SERVICE}}"

        echo "Creating tarball: ${TAR}"
        {{.SUDO}} tar -czf "${TAR}" \
          "{{.OPENBAO_CONFIG_DIR}}" \
          "{{.OPENBAO_DATA_DIR}}" \
          /etc/systemd/system/"{{.OPENBAO_SERVICE}}".service \
          2>/dev/null || {{.SUDO}} tar -czf "${TAR}" "{{.OPENBAO_CONFIG_DIR}}" "{{.OPENBAO_DATA_DIR}}"

        echo "Starting OpenBao..."
        {{.SUDO}} systemctl start "{{.OPENBAO_SERVICE}}"

        if [ "{{.ENCRYPT}}" = "1" ]; then
          if ! command -v sops >/dev/null 2>&1; then
            echo "sops not found. Run: task secrets:sops:install (or task secrets:secrets) and retry."
            exit 1
          fi

          echo "Encrypting backup with SOPS: ${ENC}"
          # Encrypt the tarball as a binary blob using the age recipients from .sops.yaml rules
          # SOPS will include metadata and keep the ciphertext safe for offsite storage.
          sops --input-type binary --output-type binary -e "${TAR}" > "${ENC}"
          rm -f "${TAR}"
          echo "Backup complete (encrypted): ${ENC}"
        else
          echo "Backup complete (plaintext): ${TAR}"
          echo "Note: store plaintext backups only on encrypted storage."
        fi

        if [ "{{.KEEP_DAYS}}" != "0" ]; then
          echo "Pruning backups older than {{.KEEP_DAYS}} days in {{.BACKUP_DIR}}..."
          find "{{.BACKUP_DIR}}" -type f \( -name "openbao-backup-*.tar.gz" -o -name "openbao-backup-*.tar.gz.sops" \) -mtime +"{{.KEEP_DAYS}}" -print -delete || true
        fi

  openbao:restore:
    desc: "Restore OpenBao from a backup tarball (plaintext .tar.gz or encrypted .tar.gz.sops)."
    vars:
      FILE: "{{.FILE}}"
    cmds:
      - |
        set -euo pipefail

        [ -n "{{.FILE}}" ] || (echo "FILE is required, e.g. task openbao:restore -- FILE=~/backups/openbao/openbao-backup-<ts>.tar.gz.sops" && exit 1)

        TMP="$(mktemp -d)"
        trap 'rm -rf "${TMP}"' EXIT

        IN="{{.FILE}}"
        OUT="${TMP}/restore.tar.gz"

        echo "Stopping OpenBao..."
        {{.SUDO}} systemctl stop "{{.OPENBAO_SERVICE}}"

        if echo "${IN}" | grep -qE '\.sops$'; then
          if ! command -v sops >/dev/null 2>&1; then
            echo "sops not found. Install it before restoring encrypted backups."
            exit 1
          fi
          echo "Decrypting encrypted backup to temporary file..."
          sops --input-type binary --output-type binary -d "${IN}" > "${OUT}"
        else
          echo "Using plaintext backup..."
          cp -f "${IN}" "${OUT}"
        fi

        echo "Restoring files into / ..."
        {{.SUDO}} tar -xzf "${OUT}" -C /

        echo "Ensuring ownership/permissions..."
        {{.SUDO}} chown -R "{{.OPENBAO_USER}}:{{.OPENBAO_GROUP}}" "{{.OPENBAO_CONFIG_DIR}}" "{{.OPENBAO_DATA_DIR}}" || true
        {{.SUDO}} chmod 750 "{{.OPENBAO_CONFIG_DIR}}" "{{.OPENBAO_DATA_DIR}}" || true

        echo "Reloading systemd and starting OpenBao..."
        {{.SUDO}} systemctl daemon-reload
        {{.SUDO}} systemctl start "{{.OPENBAO_SERVICE}}"

        echo
        echo "Restore complete."
        echo "OpenBao may be sealed after restore. Check with: bao status"
        echo "If sealed, unseal using your threshold keys: bao operator unseal"